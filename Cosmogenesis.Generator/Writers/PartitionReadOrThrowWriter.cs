using System.Linq;
using Microsoft.CodeAnalysis;

namespace Cosmogenesis.Generator.Writers
{
    class PartitionReadOrThrowWriter
    {
        public static void Write(GeneratorExecutionContext context, DbPartitionModel partitionModel)
        {
            var s = $@"
using System;
using System.Threading.Tasks;
using Microsoft.Azure.Cosmos;
using Cosmogenesis.Core;

namespace {partitionModel.DbModel.Namespace}
{{
    public class {partitionModel.ReadOrThrowClassName}
    {{
        protected virtual {partitionModel.DbModel.DbClassName} {partitionModel.DbModel.DbClassName} {{ get; }} = default!;
        protected virtual PartitionKey PartitionKey {{ get; }} = default!;

        /// <summary>Mocking constructor</summary>
        protected {partitionModel.ReadOrThrowClassName}() {{ }}

        protected internal {partitionModel.ReadOrThrowClassName}(
            {partitionModel.DbModel.DbClassName} {partitionModel.DbModel.DbClassName.Parameterify()},
            PartitionKey partitionKey)
        {{
            this.{partitionModel.DbModel.DbClassName} = {partitionModel.DbModel.DbClassName.Parameterify()} ?? throw new ArgumentNullException(nameof({partitionModel.DbModel.DbClassName.Parameterify()}));
            this.PartitionKey = partitionKey;
        }}

{string.Concat(partitionModel.Documents.Values.Select(ReadOrThrow))}
    }}
}}
";

            context.AddSource($"partition_{partitionModel.ReadOrThrowClassName}.cs", s);
        }

        static string ReadOrThrow(DbDocumentModel documentModel) => $@"
        /// <summary>
        /// Try to load a {documentModel.ClassName} by id.
        /// id should be transformed using DbDocHelper.GetValidId.
        /// Returns the {documentModel.ClassName} or throws DbConflictException if not found.
        /// </summary>
        /// <exception cref=""DbOverloadedException"" />
        /// <exception cref=""DbConflictException"" />
        /// <exception cref=""DbUnknownStatusCodeException"" />
        protected virtual async Task<{documentModel.ClassFullName}> {documentModel.ClassName}ByIdAsync(string id)
        {{
            var result = await {documentModel.DbPartitionModel.DbModel.DbClassName}.ReadByIdAsync<{documentModel.ClassFullName}>(
                partitionKey: PartitionKey, 
                id: id, 
                type: {documentModel.ConstDocType}).ConfigureAwait(false);
            if (result is null)
            {{
                throw DbModelFactory.CreateDbConflictException(dbConflictType: DbConflictType.Missing);
            }}
            return result;
        }}

        /// <summary>
        /// Try to load a {documentModel.ClassName} using an id generated by the parameters.
        /// Returns the {documentModel.ClassName} or throws DbConflictException if not found.
        /// </summary>
        /// <exception cref=""DbOverloadedException"" />
        /// <exception cref=""DbConflictException"" />
        /// <exception cref=""DbUnknownStatusCodeException"" />
        public virtual async Task<{documentModel.ClassFullName}> {documentModel.ClassName}Async({documentModel.GetIdModel.InputParameters})
        {{
            var result = await {documentModel.DbPartitionModel.DbModel.DbClassName}.ReadByIdAsync<{documentModel.ClassFullName}>(
                partitionKey: PartitionKey, 
                id: DbDocHelper.GetValidId({documentModel.GetIdModel.FullMethodName}({documentModel.GetIdModel.InputParameterMapping})), 
                type: {documentModel.ConstDocType}).ConfigureAwait(false);
            if (result is null)
            {{
                throw DbModelFactory.CreateDbConflictException(dbConflictType: DbConflictType.Missing);
            }}
            return result;
        }}
";
    }
}
